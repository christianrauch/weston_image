/* Generated by wayland-scanner 1.12.0 */

#ifndef DESKTOP_CLIENT_PROTOCOL_H
#define DESKTOP_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_desktop The desktop protocol
 * @section page_ifaces_desktop Interfaces
 * - @subpage page_iface_desktop_shell - create desktop widgets and helpers
 * - @subpage page_iface_screensaver - interface for implementing screensavers
 */
struct desktop_shell;
struct screensaver;
struct wl_output;
struct wl_surface;

/**
 * @page page_iface_desktop_shell desktop_shell
 * @section page_iface_desktop_shell_desc Description
 *
 * Traditional user interfaces can rely on this interface to define the
 * foundations of typical desktops. Currently it's possible to set up
 * background, panels and locking surfaces.
 * @section page_iface_desktop_shell_api API
 * See @ref iface_desktop_shell.
 */
/**
 * @defgroup iface_desktop_shell The desktop_shell interface
 *
 * Traditional user interfaces can rely on this interface to define the
 * foundations of typical desktops. Currently it's possible to set up
 * background, panels and locking surfaces.
 */
extern const struct wl_interface desktop_shell_interface;
/**
 * @page page_iface_screensaver screensaver
 * @section page_iface_screensaver_desc Description
 *
 * Only one client can bind this interface at a time.
 * @section page_iface_screensaver_api API
 * See @ref iface_screensaver.
 */
/**
 * @defgroup iface_screensaver The screensaver interface
 *
 * Only one client can bind this interface at a time.
 */
extern const struct wl_interface screensaver_interface;

#ifndef DESKTOP_SHELL_CURSOR_ENUM
#define DESKTOP_SHELL_CURSOR_ENUM
enum desktop_shell_cursor {
	DESKTOP_SHELL_CURSOR_NONE = 0,
	DESKTOP_SHELL_CURSOR_RESIZE_TOP = 1,
	DESKTOP_SHELL_CURSOR_RESIZE_BOTTOM = 2,
	DESKTOP_SHELL_CURSOR_ARROW = 3,
	DESKTOP_SHELL_CURSOR_RESIZE_LEFT = 4,
	DESKTOP_SHELL_CURSOR_RESIZE_TOP_LEFT = 5,
	DESKTOP_SHELL_CURSOR_RESIZE_BOTTOM_LEFT = 6,
	DESKTOP_SHELL_CURSOR_MOVE = 7,
	DESKTOP_SHELL_CURSOR_RESIZE_RIGHT = 8,
	DESKTOP_SHELL_CURSOR_RESIZE_TOP_RIGHT = 9,
	DESKTOP_SHELL_CURSOR_RESIZE_BOTTOM_RIGHT = 10,
	DESKTOP_SHELL_CURSOR_BUSY = 11,
};
#endif /* DESKTOP_SHELL_CURSOR_ENUM */

#ifndef DESKTOP_SHELL_PANEL_POSITION_ENUM
#define DESKTOP_SHELL_PANEL_POSITION_ENUM
enum desktop_shell_panel_position {
	DESKTOP_SHELL_PANEL_POSITION_TOP = 0,
	DESKTOP_SHELL_PANEL_POSITION_BOTTOM = 1,
	DESKTOP_SHELL_PANEL_POSITION_LEFT = 2,
	DESKTOP_SHELL_PANEL_POSITION_RIGHT = 3,
};
#endif /* DESKTOP_SHELL_PANEL_POSITION_ENUM */

#ifndef DESKTOP_SHELL_ERROR_ENUM
#define DESKTOP_SHELL_ERROR_ENUM
enum desktop_shell_error {
	/**
	 * an invalid argument was provided in a request
	 */
	DESKTOP_SHELL_ERROR_INVALID_ARGUMENT = 0,
};
#endif /* DESKTOP_SHELL_ERROR_ENUM */

/**
 * @ingroup iface_desktop_shell
 * @struct desktop_shell_listener
 */
struct desktop_shell_listener {
	/**
	 */
	void (*configure)(void *data,
			  struct desktop_shell *desktop_shell,
			  uint32_t edges,
			  struct wl_surface *surface,
			  int32_t width,
			  int32_t height);
	/**
	 * tell the client to create, set the lock surface
	 *
	 * Tell the client we want it to create and set the lock surface,
	 * which is a GUI asking the user to unlock the screen. The lock
	 * surface is announced with 'set_lock_surface'. Whether or not the
	 * client actually implements locking, it MUST send 'unlock'
	 * request to let the normal desktop resume.
	 */
	void (*prepare_lock_surface)(void *data,
				     struct desktop_shell *desktop_shell);
	/**
	 * tell client what cursor to show during a grab
	 *
	 * This event will be sent immediately before a fake enter event
	 * on the grab surface.
	 */
	void (*grab_cursor)(void *data,
			    struct desktop_shell *desktop_shell,
			    uint32_t cursor);
};

/**
 * @ingroup desktop_shell_iface
 */
static inline int
desktop_shell_add_listener(struct desktop_shell *desktop_shell,
			   const struct desktop_shell_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) desktop_shell,
				     (void (**)(void)) listener, data);
}

#define DESKTOP_SHELL_SET_BACKGROUND 0
#define DESKTOP_SHELL_SET_PANEL 1
#define DESKTOP_SHELL_SET_LOCK_SURFACE 2
#define DESKTOP_SHELL_UNLOCK 3
#define DESKTOP_SHELL_SET_GRAB_SURFACE 4
#define DESKTOP_SHELL_DESKTOP_READY 5
#define DESKTOP_SHELL_SET_PANEL_POSITION 6

/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_PREPARE_LOCK_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_GRAB_CURSOR_SINCE_VERSION 1

/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_SET_BACKGROUND_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_SET_PANEL_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_SET_LOCK_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_UNLOCK_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_SET_GRAB_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_DESKTOP_READY_SINCE_VERSION 2
/**
 * @ingroup iface_desktop_shell
 */
#define DESKTOP_SHELL_SET_PANEL_POSITION_SINCE_VERSION 3

/** @ingroup iface_desktop_shell */
static inline void
desktop_shell_set_user_data(struct desktop_shell *desktop_shell, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) desktop_shell, user_data);
}

/** @ingroup iface_desktop_shell */
static inline void *
desktop_shell_get_user_data(struct desktop_shell *desktop_shell)
{
	return wl_proxy_get_user_data((struct wl_proxy *) desktop_shell);
}

static inline uint32_t
desktop_shell_get_version(struct desktop_shell *desktop_shell)
{
	return wl_proxy_get_version((struct wl_proxy *) desktop_shell);
}

/** @ingroup iface_desktop_shell */
static inline void
desktop_shell_destroy(struct desktop_shell *desktop_shell)
{
	wl_proxy_destroy((struct wl_proxy *) desktop_shell);
}

/**
 * @ingroup iface_desktop_shell
 */
static inline void
desktop_shell_set_background(struct desktop_shell *desktop_shell, struct wl_output *output, struct wl_surface *surface)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_SET_BACKGROUND, output, surface);
}

/**
 * @ingroup iface_desktop_shell
 */
static inline void
desktop_shell_set_panel(struct desktop_shell *desktop_shell, struct wl_output *output, struct wl_surface *surface)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_SET_PANEL, output, surface);
}

/**
 * @ingroup iface_desktop_shell
 */
static inline void
desktop_shell_set_lock_surface(struct desktop_shell *desktop_shell, struct wl_surface *surface)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_SET_LOCK_SURFACE, surface);
}

/**
 * @ingroup iface_desktop_shell
 */
static inline void
desktop_shell_unlock(struct desktop_shell *desktop_shell)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_UNLOCK);
}

/**
 * @ingroup iface_desktop_shell
 *
 * The surface set by this request will receive a fake
 * pointer.enter event during grabs at position 0, 0 and is
 * expected to set an appropriate cursor image as described by
 * the grab_cursor event sent just before the enter event.
 */
static inline void
desktop_shell_set_grab_surface(struct desktop_shell *desktop_shell, struct wl_surface *surface)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_SET_GRAB_SURFACE, surface);
}

/**
 * @ingroup iface_desktop_shell
 *
 * Tell the server, that enough desktop elements have been drawn
 * to make the desktop look ready for use. During start-up, the
 * server can wait for this request with a black screen before
 * starting to fade in the desktop, for instance. If the client
 * parts of a desktop take a long time to initialize, we avoid
 * showing temporary garbage.
 */
static inline void
desktop_shell_desktop_ready(struct desktop_shell *desktop_shell)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_DESKTOP_READY);
}

/**
 * @ingroup iface_desktop_shell
 *
 * Tell the shell which side of the screen the panel is
 * located. This is so that new windows do not overlap the panel
 * and maximized windows maximize properly.
 */
static inline void
desktop_shell_set_panel_position(struct desktop_shell *desktop_shell, uint32_t position)
{
	wl_proxy_marshal((struct wl_proxy *) desktop_shell,
			 DESKTOP_SHELL_SET_PANEL_POSITION, position);
}

#define SCREENSAVER_SET_SURFACE 0


/**
 * @ingroup iface_screensaver
 */
#define SCREENSAVER_SET_SURFACE_SINCE_VERSION 1

/** @ingroup iface_screensaver */
static inline void
screensaver_set_user_data(struct screensaver *screensaver, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) screensaver, user_data);
}

/** @ingroup iface_screensaver */
static inline void *
screensaver_get_user_data(struct screensaver *screensaver)
{
	return wl_proxy_get_user_data((struct wl_proxy *) screensaver);
}

static inline uint32_t
screensaver_get_version(struct screensaver *screensaver)
{
	return wl_proxy_get_version((struct wl_proxy *) screensaver);
}

/** @ingroup iface_screensaver */
static inline void
screensaver_destroy(struct screensaver *screensaver)
{
	wl_proxy_destroy((struct wl_proxy *) screensaver);
}

/**
 * @ingroup iface_screensaver
 *
 * A screensaver surface is normally hidden, and only visible after an
 * idle timeout.
 */
static inline void
screensaver_set_surface(struct screensaver *screensaver, struct wl_surface *surface, struct wl_output *output)
{
	wl_proxy_marshal((struct wl_proxy *) screensaver,
			 SCREENSAVER_SET_SURFACE, surface, output);
}

#ifdef  __cplusplus
}
#endif

#endif
